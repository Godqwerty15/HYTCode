1509. 펠린드롬 분할
      - 펠린드롬? 문제와 동일한 방식으로 n * n 크기의 bool 배열을 선언하고 펠린드롬임을 확인하는 dp를 진행해야 한다.
      - dp는 길이가 1인 펠린드롬, 2인 펠린드롬을 미리 구성해 둔 뒤에 양옆 요소가 같으면 추가로 펠린드롬임을 등록시키는 과정을 반복하면 된다.
      - 그 후에 탑다운 함수를 만들어서 시작점부터 끝까지 펠린드롬이 성립하는 인덱스가 확인되면 거기서 펠린드롬 분할을 한 뒤에 다시 분할을 시작하는 경우의 수를 각각 구해서 test 값에 저장한 뒤 가장 작은 값을 메모에 담고 리턴한다.
      - 함수를 인덱스 0에서 시작하면 최소 분할값을 찾을 수 있다.
4929. 수열 걷기
      - 입력값을 sys로 받은 뒤에 마지막 0 값을 제거하고 data[2*i]와 data[2*i+1]에 대한 반복문을 진행한다.
      - 두 개의 수열 중 하나의 원소들의 인덱스값을 각각 딕셔너리에 저장한다.
      - 다른 수열에서 원소들을 하나하나 체크하면서 first 값을 갱신하다가 그 값이 딕셔너리 안에 존재할 때, 기존 수열의 last_pos부터 딕셔너리 값에 해당하는 원소들의 합을 구하여 second 값을 갱신하고 first 값과 비교하여 더 큰 값을 ans에 더하고 last_pos 값을 갱신한다.
      - 마지막에 남은 first와 second 값을 한번 더 구해서 더해주고 ans를 출력한다.
