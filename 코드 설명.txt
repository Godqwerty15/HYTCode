1509. 펠린드롬 분할
      - 펠린드롬? 문제와 동일한 방식으로 n * n 크기의 bool 배열을 선언하고 펠린드롬임을 확인하는 dp를 진행해야 한다.
      - dp는 길이가 1인 펠린드롬, 2인 펠린드롬을 미리 구성해 둔 뒤에 양옆 요소가 같으면 추가로 펠린드롬임을 등록시키는 과정을 반복하면 된다.
      - 그 후에 탑다운 함수를 만들어서 시작점부터 끝까지 펠린드롬이 성립하는 인덱스가 확인되면 거기서 펠린드롬 분할을 한 뒤에 다시 분할을 시작하는 경우의 수를 각각 구해서 test 값에 저장한 뒤 가장 작은 값을 메모에 담고 리턴한다.
      - 함수를 인덱스 0에서 시작하면 최소 분할값을 찾을 수 있다.
4929. 수열 걷기
      - 입력값을 sys로 받은 뒤에 마지막 0 값을 제거하고 data[2*i]와 data[2*i+1]에 대한 반복문을 진행한다.
      - 두 개의 수열 중 하나의 원소들의 인덱스값을 각각 딕셔너리에 저장한다.
      - 다른 수열에서 원소들을 하나하나 체크하면서 first 값을 갱신하다가 그 값이 딕셔너리 안에 존재할 때, 기존 수열의 last_pos부터 딕셔너리 값에 해당하는 원소들의 합을 구하여 second 값을 갱신하고 first 값과 비교하여 더 큰 값을 ans에 더하고 last_pos 값을 갱신한다.
      - 마지막에 남은 first와 second 값을 한번 더 구해서 더해주고 ans를 출력한다.
2252. 줄 세우기
      - 딕셔너리로 각 노드들에 대하여 더 큰 값을 가진 노드들을 저장한다.
      - 첫 노드부터 시작해서 각 노드의 더 큰 값을 가진 노드들을 다 출력하고 나서 현재 노드를 출력하는 재귀함수 line()을 실행한다.
      - 이때 한번 출력된 값을 check 딕셔너리로 확인해서 중복 출력을 방지한다.
      - python3로 제출하면 통과하나, pypy3로 제출하면 메모리 초과 문제가 발생한다.
2448. 별 찍기 - 11
      - 각 행의 별들은 3 과 2의 제곱수의 곱만큼의 전 행의 별의 위치를 참조하여 위치가 정해진다.
      - 반복문으로 그 짓거리를 하면 된다. 단순함.
1647. 도시 분할 계획
      - 도시를 두 묶음으로 나누어서 있는 데에는 건물 개수 N개에서 2개를 뺀 N-2개의 간선만 있으면 가능하다.
      - 그러므로 N-2개의 간선을 얼마나 효율적으로 연결하느냐가 이 문제에서 요구하는 정답이다.
      - 일단 N-2개의 간선을 사용하더라도 도시가 두 묶음으로 나뉘지 않는 상황을 방지하기 위해서 각 건물이 어떤 묶음에 포함되어 있는지를 확인하는 딕셔너리가 필요하다.
      - 두 건물이 다 아무 묶음에도 포함되어 있지 않았다면 둘이서 새로운 묶음에 포함되고, 둘 중 하나만 포함되었다면 포함되지 않은 건물을 포함된 건물의 묶음에 추가해 준다.
      - 두 건물이 다 묶음에 포함되어 있다면 두 건물이 "서로 다른" 묶음에 포함되어 있을 시엔 그 간선을 채택하고 두 묶음을 합쳐 주어야 한다. 반면 동일한 묶음에 포함되어 있다면 그 간선은 채택하지 않는다.
      - 이때 파이썬의 경우 최적화가 매우 중요하다. 두 묶음을 합칠 때 길이가 더 짧은 묶음을 더 긴 묶음에 extend해줘야 하며(단순하게 리스트 덧셈 연산을 사용하면 시간초과), 더 짧은 묶음 안에 들어 있던 건물들의 묶음 딕셔너리를 갱신해 주어야 한다.
1197. 최소 스패닝 트리
      - 바로 위 1647. 도시 분할 계획의 standard형 문제이다. 도시 분할 계획 코드의 N-2를 N-1로 풀면 통과한다.
33272. TAIDADA
      - 어떤 자연수와 XOR해서 특정 자연수 K가 나오게 하는 수는 하나 뿐이라는 걸 활용해서 딕셔너리를 활용하거나 부등호 계산으로 수열 안에 수를 넣으면 된다. 메모리 제한이 1024MB라서 딕셔너리를 만들어도 되겠지만, 좀 더 스마트하게 하고 싶다면 허진식으로
      - 자신과 K의 XOR 값이 자기보다 클 때에만 수열 안에 수를 넣는 방법이 있다.(단, 이 방법은 자기자신에 대해서 0이라는 예외가 생기기 때문에 거기에 대해서만 예외처리를 해주면 된다.)
32686. DPS
      - 시작 타이밍이 한 공격의 전체 주기로 나누어 떨어질 때는 단순히 공격시간을 주기로 나눈 몫 + 나머지에서 공격한 부분의 데미지를 ans에 더해주면 된다.
      - 시작 타이밍이 한 공격의 전체 주기로 나누어 떨어지지 않을 때는 두 가지 경우의 수가 생긴다.
      - 이미 시작된 공격을 끝내고도 시간이 남을 경우에는 그 공격을 끝내고 남은 시간을 기준으로 원래 돌리는 알고리즘을 실행하면 된다.
      - 이미 시작된 공격을 끝낼 시간조차 안 될 경우에는 그에 맞게 데미지를 계산해 주어야 한다.
20438. 출석체크
      - 말이 출석체크지 결국은 구간 안에서 특정 값들을 여러 번 빠르게 찾을 수 있어야 하는 문제이기 때문에 양 방향으로의 누적합을 계산해서 활용하는 문제다.
3152. 예쁜 숫자
      - 3 이상의 자연수 p를 기준으로 하는 무한 이진트리에서 오직 한 쌍의 두 노드의 합만으로 만들어지는 숫자들은 길이가 2인 경우에 p의 제곱수 중에서 2개만을 사용해야 하며 계수는 (1,1), (1,2), (2,1)만이 가능하다.
      - 길이가 3 이상인 경우에는 계수가 1인 제곱수가 단 한 개만 존재하고 나머지는 모두 계수가 2여야 한다. 이는 계수가 2인 제곱수를 대칭적으로 나눠 가지면서 하나의 제곱수만을 추가로 가져야 단 하나의 경우의 수가 만들어지기 때문이다.
      - 파이썬 기준 정수 나눗셈을 사용하지 않으면 코드가 틀리는 문제가 발생한다.
2143. 두 배열의 합
      - 부분배열의 합은 특정 번호부터 다른 특정 번호까지의 배열의 모든 요소의 합이다. 그러므로 배열의 길이가 n이라고 하면 1부터 n까지의 합만큼 존재한다.
      - 다행이게도 두 배열의 길이 제한이 1000이기 때문에 50만500 이상의 크기의 배열 2개면 부분배열의 합을 모두 저장할 수 있다.
      - 저장해 놓은 부분배열의 합 배열을 qsort해서 투포인터로 합 T가 나오는 경우를 ans에 다 더하면 되는데, 이때 유의해야 한다.
      - 둘이 더해서 T가 나오는 짝을 하나 찾았을 때, start 기준에서 왼쪽에 있는 중복되는 값들의 개수, end 기준에서 오른쪽에 있는 중복되는 값들의 개수를 모두 곱해서 더해주어야 한다.
      - 이때 ans 값은 2천5백억 이상이 나올 수 있기 때문에 곱셈 계산에도 당연히 long long 자료형을 사용해야 한다.
16946. 벽 부수고 이동하기 4
      - 간단하지만 구현이 어려운 문제다. 1 주변에 연속적으로 붙어 있는 0의 개수에 + 1을 한 값을 10으로 나눈 나머지를 1을 대신해 출력하면 된다.
      - 그러기 위해서 수상한 배추 유형의 코드를 활용해 연속적인 0의 개수를 전역변수 check에 저장하고, 이미 센 부분들에 대해서는 특정한 num 값을 새겨 줘야 한다. (그래야 한 뭉치인 걸 알 수 있다.)
      - 그 다음에 따로 spread 코드를 만들어서 check값을 뭉탱이에 속하는 모든 0의 메모값에 저장한다.
      - 그 후 check 값은 0으로 초기화, num 값은 -1을 하는 식으로 갱신을 해 주면서 새로운 뭉탱이를 또 찾는다. 
      - 이 과정을 반복한 후에 1 기준에서 상하좌우에 붙어있는 메모값을 확인하면 되는데, 이미 확인된 num값을 가지고 있을 경우 추가하지 않는 알고리즘으로 진행하면 된다.
16724. 피리부는 사나이
      - 사이클을 하나 찾을 때마다 전역변수 ans의 값을 +1하고, 사이클을 찾는 도중 기존 사이클에 편입되는 루트가 나온다면 그대로 종료하는 재귀 함수를 통해서 배열 전체를 한번 순회하면 정답을 구할 수 있다.
