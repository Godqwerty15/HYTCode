1509. 펠린드롬 분할
      - 펠린드롬? 문제와 동일한 방식으로 n * n 크기의 bool 배열을 선언하고 펠린드롬임을 확인하는 dp를 진행해야 한다.
      - dp는 길이가 1인 펠린드롬, 2인 펠린드롬을 미리 구성해 둔 뒤에 양옆 요소가 같으면 추가로 펠린드롬임을 등록시키는 과정을 반복하면 된다.
      - 그 후에 탑다운 함수를 만들어서 시작점부터 끝까지 펠린드롬이 성립하는 인덱스가 확인되면 거기서 펠린드롬 분할을 한 뒤에 다시 분할을 시작하는 경우의 수를 각각 구해서 test 값에 저장한 뒤 가장 작은 값을 메모에 담고 리턴한다.
      - 함수를 인덱스 0에서 시작하면 최소 분할값을 찾을 수 있다.
4929. 수열 걷기
      - 입력값을 sys로 받은 뒤에 마지막 0 값을 제거하고 data[2*i]와 data[2*i+1]에 대한 반복문을 진행한다.
      - 두 개의 수열 중 하나의 원소들의 인덱스값을 각각 딕셔너리에 저장한다.
      - 다른 수열에서 원소들을 하나하나 체크하면서 first 값을 갱신하다가 그 값이 딕셔너리 안에 존재할 때, 기존 수열의 last_pos부터 딕셔너리 값에 해당하는 원소들의 합을 구하여 second 값을 갱신하고 first 값과 비교하여 더 큰 값을 ans에 더하고 last_pos 값을 갱신한다.
      - 마지막에 남은 first와 second 값을 한번 더 구해서 더해주고 ans를 출력한다.
2252. 줄 세우기
      - 딕셔너리로 각 노드들에 대하여 더 큰 값을 가진 노드들을 저장한다.
      - 첫 노드부터 시작해서 각 노드의 더 큰 값을 가진 노드들을 다 출력하고 나서 현재 노드를 출력하는 재귀함수 line()을 실행한다.
      - 이때 한번 출력된 값을 check 딕셔너리로 확인해서 중복 출력을 방지한다.
2448. 별 찍기 - 11
      - 각 행의 별들은 3 과 2의 제곱수의 곱만큼의 전 행의 별의 위치를 참조하여 위치가 정해진다.
      - 반복문으로 그 짓거리를 하면 된다. 단순함.
1647. 도시 분할 계획
      - 도시를 두 묶음으로 나누어서 있는 데에는 건물 개수 N개에서 2개를 뺀 N-2개의 간선만 있으면 가능하다.
      - 그러므로 N-2개의 간선을 얼마나 효율적으로 연결하느냐가 이 문제에서 요구하는 정답이다.
      - 일단 N-2개의 간선을 사용하더라도 도시가 두 묶음으로 나뉘지 않는 상황을 방지하기 위해서 각 건물이 어떤 묶음에 포함되어 있는지를 확인하는 딕셔너리가 필요하다.
      - 두 건물이 다 아무 묶음에도 포함되어 있지 않았다면 둘이서 새로운 묶음에 포함되고, 둘 중 하나만 포함되었다면 포함되지 않은 건물을 포함된 건물의 묶음에 추가해 준다.
      - 두 건물이 다 묶음에 포함되어 있다면 두 건물이 "서로 다른" 묶음에 포함되어 있을 시엔 그 간선을 채택하고 두 묶음을 합쳐 주어야 한다. 반면 동일한 묶음에 포함되어 있다면 그 간선은 채택하지 않는다.
      - 이때 파이썬의 경우 최적화가 매우 중요하다. 두 묶음을 합칠 때 길이가 더 짧은 묶음을 더 긴 묶음에 extend해줘야 하며(단순하게 리스트 덧셈 연산을 사용하면 시간초과), 더 짧은 묶음 안에 들어 있던 건물들의 묶음 딕셔너리를 갱신해 주어야 한다.
1197. 최소 스패닝 트리
      - 바로 위 1647. 도시 분할 계획의 standard형 문제이다. 도시 분할 계획 코드의 N-2를 N-1로 풀면 통과한다.
33272. TAIDADA
      - 어떤 자연수와 XOR해서 특정 자연수 K가 나오게 하는 수는 하나 뿐이라는 걸 활용해서 딕셔너리를 활용하거나 부등호 계산으로 수열 안에 수를 넣으면 된다. 메모리 제한이 1024MB라서 딕셔너리를 만들어도 되겠지만, 좀 더 스마트하게 하고 싶다면 허진식으로
      - 자신과 K의 XOR 값이 자기보다 클 때에만 수열 안에 수를 넣는 방법이 있다.(단, 이 방법은 자기자신에 대해서 0이라는 예외가 생기기 때문에 거기에 대해서만 예외처리를 해주면 된다.)
32686. DPS
      - 시작 타이밍이 한 공격의 전체 주기로 나누어 떨어질 때는 단순히 공격시간을 주기로 나눈 몫 + 나머지에서 공격한 부분의 데미지를 ans에 더해주면 된다.
      - 시작 타이밍이 한 공격의 전체 주기로 나누어 떨어지지 않을 때는 두 가지 경우의 수가 생긴다.
      - 이미 시작된 공격을 끝내고도 시간이 남을 경우에는 그 공격을 끝내고 남은 시간을 기준으로 원래 돌리는 알고리즘을 실행하면 된다.
      - 이미 시작된 공격을 끝낼 시간조차 안 될 경우에는 그에 맞게 데미지를 계산해 주어야 한다.
20438. 출석체크
      - 말이 출석체크지 결국은 구간 안에서 특정 값들을 여러 번 빠르게 찾을 수 있어야 하는 문제이기 때문에 양 방향으로의 누적합을 계산해서 활용하는 문제다.
3152. 예쁜 숫자
      - 3 이상의 자연수 p를 기준으로 하는 무한 이진트리에서 오직 한 쌍의 두 노드의 합만으로 만들어지는 숫자들은 길이가 2인 경우에 p의 제곱수 중에서 2개만을 사용해야 하며 계수는 (1,1), (1,2), (2,1)만이 가능하다.
      - 길이가 3 이상인 경우에는 계수가 1인 제곱수가 단 한 개만 존재하고 나머지는 모두 계수가 2여야 한다. 이는 계수가 2인 제곱수를 대칭적으로 나눠 가지면서 하나의 제곱수만을 추가로 가져야 단 하나의 경우의 수가 만들어지기 때문이다.
      - 파이썬 기준 정수 나눗셈을 사용하지 않으면 코드가 틀리는 문제가 발생한다.
2143. 두 배열의 합
      - 부분배열의 합은 특정 번호부터 다른 특정 번호까지의 배열의 모든 요소의 합이다. 그러므로 배열의 길이가 n이라고 하면 1부터 n까지의 합만큼 존재한다.
      - 다행이게도 두 배열의 길이 제한이 1000이기 때문에 50만500 이상의 크기의 배열 2개면 부분배열의 합을 모두 저장할 수 있다.
      - 저장해 놓은 부분배열의 합 배열을 qsort해서 투포인터로 합 T가 나오는 경우를 ans에 다 더하면 되는데, 이때 유의해야 한다.
      - 둘이 더해서 T가 나오는 짝을 하나 찾았을 때, start 기준에서 왼쪽에 있는 중복되는 값들의 개수, end 기준에서 오른쪽에 있는 중복되는 값들의 개수를 모두 곱해서 더해주어야 한다.
      - 이때 ans 값은 2천5백억 이상이 나올 수 있기 때문에 곱셈 계산에도 당연히 long long 자료형을 사용해야 한다.
16946. 벽 부수고 이동하기 4
      - 간단하지만 구현이 어려운 문제다. 1 주변에 연속적으로 붙어 있는 0의 개수에 + 1을 한 값을 10으로 나눈 나머지를 1을 대신해 출력하면 된다.
      - 그러기 위해서 수상한 배추 유형의 코드를 활용해 연속적인 0의 개수를 전역변수 check에 저장하고, 이미 센 부분들에 대해서는 특정한 num 값을 새겨 줘야 한다. (그래야 한 뭉치인 걸 알 수 있다.)
      - 그 다음에 따로 spread 코드를 만들어서 check값을 뭉탱이에 속하는 모든 0의 메모값에 저장한다.
      - 그 후 check 값은 0으로 초기화, num 값은 -1을 하는 식으로 갱신을 해 주면서 새로운 뭉탱이를 또 찾는다. 
      - 이 과정을 반복한 후에 1 기준에서 상하좌우에 붙어있는 메모값을 확인하면 되는데, 이미 확인된 num값을 가지고 있을 경우 추가하지 않는 알고리즘으로 진행하면 된다.
16724. 피리부는 사나이
      - 사이클을 하나 찾을 때마다 전역변수 ans의 값을 +1하고, 사이클을 찾는 도중 기존 사이클에 편입되는 루트가 나온다면 그대로 종료하는 재귀 함수를 통해서 배열 전체를 한번 순회하면 정답을 구할 수 있다.
10975. 데크 소트 2
      - 입력을 받아서 미리 정렬된 배열을 만들어 놓는다.
      - 이분탐색을 통해서 입력받은 숫자가 들어갈 위치를 찾는다.
      - 입력받은 숫자의 양옆 숫자들이 이미 들어와 있으면 ans 값을 +1하고, 들어와 있지 않으면 딕셔너리 갱신만 하면서 그대로 진행한다.
3020. 개똥벌레
      - 석순 기준 높이 1~H에 따라서 파괴해야 하는 석순의 개수를 메모한다.
      - 종유석 기준 높이 1~H에 따라서 파괴해야 하는 종유석의 개수를 메모한다.
      - 높이 별로 파괴해야 하는 석순과 종유석의 합 중 최솟값을 찾으며, 최솟값의 개수를 기록하는 변수 s는 최솟값이 발견될 때마다 1로 초기화되고 최솟값과 동일한 값이 발견되면 +1된다.
2623. 음악 프로그램
      - 클래스로 각 번호 별 앞서 나와야 하는 번호와 뒤에 나와야 하는 번호를 저장한다.
      - 앞서 나와야 하는 번호를 ans 리스트에 넣고 그 다음에 자기를 넣는 재귀함수를 실행한다.
      - ans 리스트 안에 자녀보다 부모가 먼저 나온 오류가 없는지 확인하고, 오류가 있으면 불가능한 것이므로 0을 출력하며, 오류가 없다면 ans 리스트를 출력한다.
1202. 보석 도둑
      - 가방을 크기 순으로 정렬해놓고 각 가방 당 담을 수 있는 보석의 수를 메모해 놓는다.
      - 메모 값이 같은 가방끼리 메모 값에 해당하는 무게까지의 보석 중에서 가장 가치가 큰 보석을 담을 수 있는대로 담는다.
      - 이때 부분정렬을 해야 하는데, 부분정렬을 하고 보석을 담은 뒤 남은 보석은 힙에 넣어서 다음 부분정렬을 할 때 비교한다.
      - 그러나 이 방법보다 상당히 시간 복잡도가 낮은 방법이 하나 더 있는데, 보석의 가치 / 무게 별로 2개의 우선순위 큐를 만들고 크기가 작은 가방부터 채워가는 방법이 있다고 한다.
28066. 타노스는 요세푸스가 밉다
      - 이중 리스트로 나의 앞의 노드는 나의 뒤의 노드의 정보를 전달받고, 나의 뒤의 노드는 나의 앞의 노드를 전달받도록 하는 반복문을 실행한다.
      - s값을 1씩 차감하면서 반복문을 실행하고, 그 후에 K보다 작아지면 출력하면서 끝낸다.
1260. DFS와 BFS
      - DFS는 원래 하던 대로 집합에 이미 출력한 요소 체크하면서 DFS 들어가면 된다.
      - BFS는 아직 나오지 않은 요소들을 모두 모아서 다음 함수에 전달해주면 된다.
13140. Hello World!
      - 일반적인 브루트포스 풀이법의 코드 길이가 수백줄이 되기 때문에 순열을 활용하고자 했다.
      - 이때 파이썬으로 코드를 돌리면 오래 걸릴 수 있음을 고려해서 o와 d를 미리 구해놓고, 시간 복잡도를 줄이면서 진행했다.
17209. 새내기와 헌내기
      - 헌내기가 신고한 사람은 새내기, 새내기가 신고한 사람은 헌내기이기 때문에 그래프 상으로 이어진 노드들을 dfs로 탐색하면서 2가지의 유형으로 나눈 뒤에 더 큰 값을 ans에 더하면 된다.
      - 신고를 받은 적이 없는 사람은 그냥 헌내기로 추정해서 더해주면 된다.
32178. 용액 2
      - 용액의 연속합은 누적합의 차로 표현할 수 있다.
      - 누적합을 오름차순으로 정렬시켜서 각 요소들의 차 중에서 가장 작은 차가 가장 작은 연속합이 될 수 있다.
      - 그러나 오류가 있는지 나는 각 누적합들을 추가로 비교하도록 코드를 짜야 했다.
1914. 하노이 탑
      - N이 홀수일 경우 1번에 있는 걸 옮길 땐 3번이 우선, 2번에 있는 걸 옮길 땐 1번이 우선, 3번에 있는 걸 옮길 땐 2번이 우선이다.
      - N이 짝수일 경우 1번에 있는 걸 옮길 땐 2번이 우선, 2번에 있는 걸 옮길 땐 3번이 우선, 3번에 있는 걸 옮길 땐 1번이 우선이다.
      - 이 과정을 활용해서 일반항을 구하고 dp를 하는 것도 가능할 것 같으나, 나는 일단 말 그대로 '구현'했다.
17615. 볼 모으기
      - 양끝에 있는 공의 색깔을 고려해서 4가지 경우의 수에 대해서 모두 그리디 알고리즘으로 묶음의 공의 개수를 더해서 가장 작은 것을 구해주면 된다.
2342. Dance Dance Revolution
      - 러프하게 각 방향 별로 모든 경우의 수를 고려해서 10만 곱하기 5 곱하기 5의 배열로 바텀업을 진행하면 된다.
      - 발의 순서가 상관이 없다고 생각하여 코딩을 하였으나, 아무래도 발의 순서에 따라 답이 달라지는 경우가 있는 것으로 추정된다.
13977. 이항계수와 쿼리
      - 페르마의 소정리를 활용해서 10억 5제곱을 한 값을 역원으로 활용한다.
      - 기본적으로 쿼리 문제이기 때문에 4천만까지의 곱을 모두 메모리에 저장해야 풀 수 있다.
23352. 방탈출
      - C언어 기준 BFS 완전탐색이 필요하고 파이썬 기준에서는 BFS를 하되, 인접한 방이 2개 이하인 방에서만 탐색을 시작해야 한다.
      - 파이썬은 수백만번의 연산이 1초 안에 불가능하다는 것을 확실히 알 수 있는 문제다.
9251 ~ 9252. LCS, LCS 2
      - 얼마의 최대 인덱스 값을 사용하여 이 문자를 공통 부분수열 안에 저장하였는지를 메모리로 저장하면서 top-down 방식으로 다이나믹 프로그래밍을 했다.
      - LCS 2는 최대 값을 추적하는 함수를 만들어서 과정에 있는 문자들을 저장하면 된다.
      - 바텀 업 방식으로 더 효율적인 풀이가 있는 것 같다.
17071. 숨바꼭질 5
      - 홀수 시간과 짝수 시간에 그 위치에 최소로 도달할 수 있는 시간을 각각 기록한다.
      - 동생을 만날 수 있는지 확인한다.
10653. 마라톤 2
      - 남아 있는 건너뛸 수 있는 기회와 체크포인트의 수 (K x N)에 대한 행렬을 만든다.
      - 각 위치에 올 수 있는 경우의 수를 모두 고려해서 그 중에서 가장 작은 경우의 수를 담는다.
      - 마지막 노드를 꼭 밟아야 하므로 마지막 노드 기준에서 가장 작은 값을 고르면 된다.
23082. 균형 삼진법
      - N이 음수인 경우는 N이 양수인 경우의 답을 반전시켜주면 되기 때문에 N이 양수일 때만 풀 수 있으면 된다.
      - N 이상이 될 때까지 temp에 3의 제곱수를 계속 더한다.
      - N이 딱 나오면 바로 출력하면 되고, N보다 큰 수라면 거기서부터 돌아가면서 3의 제곱수를 1개 혹은 2개까지 뺄 수 있다.
      - 빼다 보면 결국 N이 나올 거고 그 답을 출력하면 된다. 
16193. 차이를 최대로 2
      - 브루트 포스 풀이가 가능하다. 다른 사람들은 덱을 사용하거나 수학적 증명을 하면서 풀기도 했다.
      - 브루트 포스로 풀 때는 N이 짝수일 때는 수를 정렬한 뒤 중간값 다음부터의 큰 수를 홀수번째 인덱스에 역배열한 뒤에 0번째 인덱스에 중간값을 넣고, 2번째 인덱스부터 가장 작은 수부터 정배열한 뒤에
      - 차이합을 구하면 된다.
      - N이 홀수일 때는 똑같이 중간값 다음부터의 큰 수를 홀수번째 인덱스에 역배열한 뒤에 0번째와 N-1번째 인덱스에 중간값과 중간값보다 하나 더 작은 값을 넣고, 2번째 인덱스부터 가장 작은 수를 정배열한
      - 예시의 차이합과, 중간값 다음의 2개의 수를 배열의 양끝에 배치한 뒤에 2번 인덱스부터 큰 숫자들을 역배열하고 1번 인덱스부터 작은 숫자들을 정배열한 예시의 차이합을 비교해서 둘 중에 더 큰 것을 
      - 출력하면 된다.
33147. K-정렬
      - K씩 넘어가다 보면 숫자들이 여러 개의 원형 그래프를 이루게 된다.
      - 그 그래프 안의 숫자들은 순서를 마음대로 변경할 수 있다.
      - 그러므로 그 그래프 안에 있는 숫자들의 인덱스에 해당하는 숫자들이 그 그래프 안에 존재하기만 한다면 정렬할 수 있는 것이다.
14003. 가장 긴 증가하는 부분수열 5
      - LIS 문제를 푸는 가장 효율적인 방법은 배열의 맨 끝에 있는 수보다 더 큰 수가 나왔다면 바로 append, 그렇지 않다면 이분탐색을 통해 left 위치를 찾고, 그 위치에 있는 수보다 현재 탐색하는 수가 작다면 그 수로 대체하는 것이다.
      - 이 방식으로 하면 결국 최장 증가수열을 구할 수 있으나, 이 문제는 최장 증가수열을 출력하는 것이 과제다.
      - 그렇기 때문에 인덱스 저장 리스트와 메모를 만들고 저장해준 뒤, 마지막 수의 인덱스 기준에서 돌아가면서 수를 찾아내 가는 과정이 필요하다. 마지막 수는 결국 어떤 방식으로든 최장 길이의 마지막에 올 수 있는 수이기 때문에
      - 이 수보다 인덱스가 작았는데 정답 수열을 구성했었던 적이 있던 수는 마지막 수보다 당연히 앞에 있을 수 있다.
      - 그러나 이 과정을 축약하기 위해 bisect 과정에서 새로 리스트를 선언하는 실수를 범한 나는 상당히 많은 시간초과의 흔적을 남겨야 했다.
27468. 2배 또는 0.5배
      - +1 +2 -1 +2의 반복 혹은 +2 -1 +2 +1의 반복으로 모든 숫자를 규칙에 맞게 출력해낼 수 있다.
